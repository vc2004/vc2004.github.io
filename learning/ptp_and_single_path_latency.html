<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PTP 精密时间同步与纳秒级延迟测量终极指南 (硬件时间戳版)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.8;
            color: #333;
            max-width: 900px;
            margin: 20px auto;
            padding: 0 20px;
            background-color: #fdfdfd;
        }

        h1,
        h2,
        h3,
        h4 {
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            color: #2c3e50;
        }

        h1 {
            font-size: 2.2em;
        }

        h2 {
            font-size: 1.8em;
            margin-top: 40px;
        }

        h3 {
            font-size: 1.4em;
            margin-top: 30px;
        }

        .mermaid {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            overflow: auto;
            /* Add overflow for better mobile view */
        }

        code {
            background-color: #eef;
            padding: 3px 6px;
            border-radius: 4px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            font-size: 0.9em;
        }

        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }

        pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }

        .note {
            background-color: #e7f3fe;
            border-left: 5px solid #2196F3;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }

        .success {
            background-color: #e8f5e9;
            border-left: 5px solid #4CAF50;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }

        .danger {
            background-color: #fbe9e7;
            border-left: 5px solid #d9534f;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            font-size: 0.9em;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
        }

        table thead tr {
            background-color: #2c3e50;
            color: #ffffff;
            text-align: left;
        }

        table th,
        table td {
            padding: 12px 15px;
        }

        table tbody tr {
            border-bottom: 1px solid #dddddd;
        }

        table tbody tr:nth-of-type(even) {
            background-color: #f3f3f3;
        }

        table tbody tr:last-of-type {
            border-bottom: 2px solid #2c3e50;
        }
    </style>
</head>

<body>

    <h1>PTP 精密时间同步与纳秒级延迟测量终极指南 (硬件时间戳版)</h1>
    <p>在现代分布式系统、高频交易和科学计算中，时间的精确同步至关重要。网络时间协议（NTP）通常只能提供毫秒级的同步精度，这在许多场景下已不敷使用。此时，**精确时间协议（Precision Time Protocol,
        PTP）**，即 IEEE 1588 标准，便成为了关键技术。</p>
    <p>本指南将带您深入了解PTP，从基础原理到协议核心，最后提供一个完整的、可运行的C语言示例，演示如何在两台已通过PTP同步的Linux机器之间，**利用网卡硬件时间戳**，实现纳秒（nanosecond）级别的单向网络延迟（One-Way
        Delay, OWD）测量。</p>

    <h2>第一部分：PTP 基础 - 什么是精确时间协议？</h2>

    <p>PTP（IEEE 1588）是一种用于在计算机网络中精确同步时钟的协议。它被设计用于局域网（LAN），能够实现亚微秒（sub-microsecond）甚至纳秒级的同步精度，远超NTP。</p>

    <h3>PTP 网络角色</h3>
    <p>一个PTP网络主要由以下角色构成：</p>
    <ul>
        <li><strong>主时钟 (Master Clock):</strong> 网络中的时间基准源。整个域内的所有其他时钟都向它看齐。</li>
        <li><strong>从时钟 (Slave Clock):</strong> 网络中需要同步时间的设备，它会根据从主时钟收到的信息来调整自己的本地时钟。</li>
        <li><strong>边界时钟 (Boundary Clock):</strong> 拥有多个端口的设备（如交换机），其中一个端口作为从时钟同步上游主时钟，其他端口则作为主时钟为下游设备提供时间。</li>
        <li><strong>透明时钟 (Transparent Clock):</strong>
            交换机等网络设备，它会测量PTP报文在设备内部的停留时间（驻留时间），并将其累加到报文的特定字段中，从而消除交换机自身带来的延迟误差。</li>
    </ul>

    <div class="mermaid">
        graph TD
        subgraph PTP Domain
        GM(Grandmaster Clock) --> BC1(Boundary Clock 1)
        GM --> Slave1(Slave Clock 1)
        BC1 --> Slave2(Slave Clock 2)
        BC1 --> TC1(Transparent Clock)
        TC1 --> Slave3(Slave Clock 3)
        end
        style GM fill:#e8f5e9,stroke:#4CAF50,stroke-width:2px
        style Slave1 fill:#e7f3fe,stroke:#2196F3,stroke-width:2px
        style Slave2 fill:#e7f3fe,stroke:#2196F3,stroke-width:2px
        style Slave3 fill:#e7f3fe,stroke:#2196F3,stroke-width:2px
    </div>

    <h3>PTP vs NTP</h3>
    <p>为什么需要PTP？它与更常见的NTP有何不同？</p>
    <table>
        <thead>
            <tr>
                <th>特性</th>
                <th>PTP (IEEE 1588)</th>
                <th>NTP (Network Time Protocol)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>目标精度</strong></td>
                <td>亚微秒到纳秒级</td>
                <td>毫秒到几十毫秒级</td>
            </tr>
            <tr>
                <td><strong>核心技术</strong></td>
                <td><strong>硬件时间戳</strong> (在网卡PHY层打点)</td>
                <td>软件时间戳 (在内核或应用层打点)</td>
            </tr>
            <tr>
                <td><strong>网络要求</strong></td>
                <td>推荐使用支持PTP的交换机和网卡</td>
                <td>对普通网络硬件即可工作</td>
            </tr>
            <tr>
                <td><strong>算法复杂度</strong></td>
                <td>相对简单，专为局域网设计</td>
                <td>更复杂，为广域网和互联网设计</td>
            </tr>
            <tr>
                <td><strong>资源消耗</strong></td>
                <td>CPU占用低，消息频率高</td>
                <td>CPU占用稍高，消息频率低</td>
            </tr>
            <tr>
                <td><strong>典型应用</strong></td>
                <td>金融交易、电信5G、工业自动化、电力网</td>
                <td>通用服务器、桌面系统、互联网服务</td>
            </tr>
        </tbody>
    </table>
    <div class="note">
        <strong>核心理念：</strong>
        PTP的杀手锏在于“硬件时间戳”。当一个PTP数据包被网卡发送或接收时，网卡硬件会立即在数据包通过物理层的那一刻记录下时间戳。这个过程绕过了充满不确定性的软件处理流程，是实现高精度的关键。
    </div>

    <h2>第二部分：PTP 核心原理 - 协议如何计算延迟与偏移</h2>
    <p>PTP同步的精髓在于精确测量“主-从”时钟之间的<strong>时钟偏移 (Clock Offset)</strong> 和<strong>网络路径延迟 (Path
            Delay)</strong>。这是通过一个双向的消息交换机制完成的。</p>
    <p>基本假设：<strong>网络路径是对称的</strong>，即从主时钟到从时钟的延迟（`T_ms`）等于从从时钟到主时钟的延迟（`T_sm`）。</p>

    <h3>消息交换与时间戳</h3>
    <p>整个过程涉及四条关键消息和四个时间戳：</p>
    <ol>
        <li><strong>Sync 消息:</strong> 主时钟周期性地向从时钟发送 `Sync` 消息。
            <ul>
                <li>`t1`: 主时钟发送 `Sync` 消息的精确时间。</li>
                <li>`t2`: 从时钟接收到 `Sync` 消息的精确时间。</li>
            </ul>
        </li>
        <li><strong>Follow_Up 消息:</strong> 紧随 `Sync` 消息之后，主时钟发送 `Follow_Up` 消息。这条消息里包含了 `Sync` 消息的精确发送时间 `t1`。
            <br><em>(为什么需要 Follow_Up？因为主时钟在生成 `Sync` 消息时，可能无法立即知道它确切的硬件发送时间戳，所以需要一个后续消息来“追认”这个时间。)</em>
        </li>
        <li><strong>Delay_Req 消息:</strong> 从时钟在稍后向主时钟发送 `Delay_Req` 消息，以请求计算反向延迟。
            <ul>
                <li>`t3`: 从时钟发送 `Delay_Req` 消息的精确时间。</li>
            </ul>
        </li>
        <li><strong>Delay_Resp 消息:</strong> 主时钟收到 `Delay_Req` 后，会记录下接收时间 `t4`，然后通过 `Delay_Resp` 消息将 `t4` 发回给从时钟。
            <ul>
                <li>`t4`: 主时钟接收到 `Delay_Req` 消息的精确时间。</li>
            </ul>
        </li>
    </ol>

    <div class="mermaid">
        sequenceDiagram
        participant Master as 主时钟
        participant Slave as 从时钟

        Master->>Slave: Sync 消息 (t1时刻发送)
        Note right of Master: 硬件记录发送时间 t1
        Note left of Slave: 硬件记录接收时间 t2
        Master->>Slave: Follow_Up 消息 (携带精确的 t1)

        Slave->>Slave: 已拥有 t1, t2

        Slave->>Master: Delay_Req 消息 (t3时刻发送)
        Note left of Slave: 硬件记录发送时间 t3
        Note right of Master: 硬件记录接收时间 t4
        Master->>Slave: Delay_Resp 消息 (含精确的 t4)

        Slave->>Slave: 已集齐 t1, t2, t3, t4
        Slave->>Slave: 计算路径延迟和时钟偏移
    </div>

    <h3>计算公式</h3>
    <p>当从时钟集齐了 `t1`, `t2`, `t3`, `t4` 四个时间戳后，就可以进行计算了。</p>

    1. <strong>主到从的延迟 (T_ms):</strong>
    `T_ms = t2 - t1 - offset`
    2. <strong>从到主的延迟 (T_sm):</strong>
    `T_sm = t4 - t3 + offset`

    基于路径对称的假设 (`T_ms = T_sm`)，可以推导出：
    `t2 - t1 - offset = t4 - t3 + offset`

    由此，可以解出两个关键参数：

    <div class="success">
        <h4>路径延迟 (Path Delay)</h4>
        <p><code>Path_Delay = (T_ms + T_sm) / 2 = ((t2 - t1) + (t4 - t3)) / 2</code></p>
        <h4>时钟偏移 (Clock Offset)</h4>
        <p>从 `t2 - t1 - offset = Path_Delay` 推导：</p>
        <p><code>Offset = (t2 - t1) - Path_Delay = ((t2 - t1) - (t4 - t3)) / 2</code></p>
    </div>

    <p>从时钟计算出 `Offset` 后，就可以调整自己的本地时钟，使其与主时钟对齐。这个过程会持续进行，不断修正，从而实现高精度的同步。</p>

    <h2>第三部分：准备工作 - 配置PTP同步环境</h2>
    <p>了解了核心原理后，便可以开始动手配置一个PTP环境。假设有两台Linux机器（例如，`Host A` 和 `Host B`），它们通过网络连接。</p>

    <h3>1. 检查网卡是否支持PTP</h3>
    <p>在两台机器上，使用 <code>ethtool</code> 命令检查您的网卡是否支持硬件时间戳。将 <code>eth0</code> 替换为您的实际网卡名称。</p>
    <pre><code>ethtool -T eth0</code></pre>
    <p>需要关注的输出是：</p>
    <pre><code>Capabilities:
    hardware-transmit     (SOF_TIMESTAMPING_TX_HARDWARE)
    hardware-receive      (SOF_TIMESTAMPING_RX_HARDWARE)
    hardware-raw-clock    (SOF_TIMESTAMPING_RAW_HARDWARE)
PTP Hardware Clock: 0
Hardware Transmit Timestamp Modes:
    off                   (HWTSTAMP_TX_OFF)
    on                    (HWTSTAMP_TX_ON)
Hardware Receive Filter Modes:
    none                  (HWTSTAMP_FILTER_NONE)
    all                   (HWTSTAMP_FILTER_ALL)
</code></pre>
    <div class="success">
        如果看到 `hardware-transmit` 和 `hardware-receive`，并有一个 `PTP Hardware Clock` 设备（如 `PTP Hardware Clock:
        0`），那么恭喜，您的硬件已准备就绪！这个设备通常对应 <code>/dev/ptp0</code>。
    </div>

    <h3>2. 安装PTP工具</h3>
    <p>在基于Debian/Ubuntu的系统上：</p>
    <pre><code>sudo apt-get update
sudo apt-get install linuxptp</code></pre>
    <p>在基于RedHat/CentOS的系统上：</p>
    <pre><code>sudo yum install linuxptp</code></pre>

    <h3>3. 运行PTP同步</h3>
    <p>PTP网络中需要一个主时钟（Master）和一个或多个从时钟（Slave）。</p>
    <ul>
        <li>在您选作**主时钟**的机器上（例如 Host A）运行 <code>ptp4l</code>：</li>
    </ul>
    <pre><code># -i 指定网卡, -m 表示以Master模式启动, -2 表示使用PTPv2
sudo ptp4l -i eth0 -m -2</code></pre>
    <ul>
        <li>在**从时钟**机器上（例如 Host B）运行 <code>ptp4l</code>：</li>
    </ul>
    <pre><code># -s 表示以Slave模式启动
sudo ptp4l -i eth0 -s -m -2</code></pre>
    <p><code>ptp4l</code> 运行时，它会自动在网络中进行主从选举（BMCA），并开始同步从时钟的PHC（例如 <code>/dev/ptp0</code>）到主时钟的PHC。您会看到类似 `phc_ctl ...
        offset ... s2` 的日志，表示正在调整时钟。</p>

    <h3>4. 同步系统时钟 (可选但推荐)</h3>
    <p><code>ptp4l</code> 只同步了网卡的PHC。还需要将系统的`CLOCK_REALTIME`或`CLOCK_TAI`同步到这个精确的PHC。这由 <code>phc2sys</code> 完成。</p>
    <pre><code># -s 指定PHC设备, -c 指定系统时钟, -w 等待ptp4l稳定, -m 打印日志
sudo phc2sys -s eth0 -c CLOCK_REALTIME -w -m</code></pre>
    <p>经过以上步骤，两台机器的网卡硬件时钟（PHC）已经达到了纳秒级的同步！</p>

    <h2>第四部分：终极方案 - 使用硬件时间戳测量纳秒级延迟</h2>
    <p>现在，环境已经就绪。接下来将编写C代码来执行单向延迟测量。与之前仅在软件层面读取时钟不同，这次将直接利用网卡的硬件时间戳能力。</p>

    <h3>新的工作流程</h3>
    <p>由于发送时间戳是在数据包离开发送方网卡后才能获得，通信协议变得稍微复杂一些。需要两种类型的包：</p>
    <ul>
        <li><strong>DATA_PACKET</strong>: 包含序列号和一些载荷数据。</li>
        <li><strong>TIMESTAMP_PACKET</strong>: 专门用于传递某个 `DATA_PACKET` 的硬件发送时间戳。</li>
    </ul>

    <div class="mermaid">
        sequenceDiagram
        participant SenderApp as "发送端应用"
        participant SenderNIC as "发送端网卡 (硬件)"
        participant ReceiverNIC as "接收端网卡 (硬件)"
        participant ReceiverApp as "接收端应用"

        SenderApp->>SenderNIC: 1. 发送 DATA_PACKET (seq=N)
        note right of SenderNIC: 硬件在物理层发送时<br />记录发送时间戳 T_send_hw
        SenderNIC-->>SenderApp: 2. 通过错误队列返回 T_send_hw

        SenderApp->>SenderNIC: 3. 发送 TIMESTAMP_PACKET<br />(包含 seq=N 的 T_send_hw)

        activate ReceiverNIC
        SenderNIC->>ReceiverNIC: (网络传输 DATA_PACKET)
        note left of ReceiverNIC: 硬件在物理层接收时<br />记录接收时间戳 T_receive_hw
        ReceiverNIC->>ReceiverApp: 4. 通过cmsg上报 T_receive_hw<br />和 DATA_PACKET
        deactivate ReceiverNIC
        note over ReceiverApp: 暂存 T_receive_hw

        activate ReceiverNIC
        SenderNIC->>ReceiverNIC: (网络传输 TIMESTAMP_PACKET)
        ReceiverNIC->>ReceiverApp: 5. 上报 TIMESTAMP_PACKET
        deactivate ReceiverNIC

        ReceiverApp->>ReceiverApp: 6. 匹配 seq=N, 计算延迟<br />Delay = T_receive_hw - T_send_hw
    </div>

    <div class="danger">
        <strong>核心变化：</strong>此方法更为复杂。发送方在发送数据包后，需要从套接字的**错误队列 (Error Queue)** 中取回由硬件生成的发送时间戳，然后通过第二个包将其发送给接收方。
    </div>

    <h3>实战代码 - C语言实现</h3>
    <p>代码分为三个文件：一个通用头文件和两个主程序。</p>

    <h4>通用头文件 (`common.h`)</h4>
    <p>定义了两种数据包的类型和共享的结构体。</p>
    <pre><code class="language-c">#ifndef COMMON_H
#define COMMON_H

#include &lt;time.h&gt;
#include &lt;stdint.h&gt;

// 包类型
enum packet_type {
    DATA_PACKET,
    TIMESTAMP_PACKET
};

// 数据包结构体
struct owd_packet {
    enum packet_type type;
    uint32_t seq_num;
    union {
        // 用于 TIMESTAMP_PACKET
        struct timespec ts; 
        // 用于 DATA_PACKET (可以填充一些数据)
        char payload[128]; 
    } data;
};

#endif // COMMON_H
</code></pre>

    <h4>`receiver.c` (接收端)</h4>
    <p>接收端现在需要处理控制信息（`cmsg`）来提取硬件时间戳，并能够处理两种不同类型的包。</p>
    <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;linux/net_tstamp.h&gt;
#include "common.h" // 引入通用头文件

// 简单的哈希表，用于存储接收时间戳，等待匹配的发送时间戳
// 在实际应用中，应使用更健壮的数据结构
#define MAX_SEQ 1024
struct timespec rx_timestamps[MAX_SEQ];
int rx_ts_valid[MAX_SEQ] = {0};

void die(char *s) {
    perror(s);
    exit(1);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "用法: %s &lt;端口号&gt;\n", argv[0]);
        exit(1);
    }

    int port = atoi(argv[1]);
    struct sockaddr_in si_me, si_other;
    int s, slen = sizeof(si_other);

    if ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) die("socket");

    // *** 关键步骤: 开启硬件时间戳 ***
    // SOF_TIMESTAMPING_RAW_HARDWARE: 请求原始的硬件时间戳，它直接来自PHC
    // SOF_TIMESTAMPING_RX_HARDWARE:  对接收的包进行硬件时间戳
    int ts_flags = SOF_TIMESTAMPING_RX_HARDWARE | SOF_TIMESTAMPING_RAW_HARDWARE;
    if (setsockopt(s, SOL_SOCKET, SO_TIMESTAMPING, &amp;ts_flags, sizeof(ts_flags)) &lt; 0) {
        die("setsockopt SO_TIMESTAMPING");
    }

    memset((char *)&amp;si_me, 0, sizeof(si_me));
    si_me.sin_family = AF_INET;
    si_me.sin_port = htons(port);
    si_me.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(s, (struct sockaddr*)&amp;si_me, sizeof(si_me)) == -1) die("bind");

    printf("接收端已启动，在端口 %d 上等待数据...\n", port);
    printf("------------------------------------------------------------------\n");
    printf("%-10s | %-18s | %-15s\n", "序列号", "单向延迟 (ns)", "发送方地址");
    printf("------------------------------------------------------------------\n");

    while (1) {
        char buf[2048];
        struct owd_packet *pkt = (struct owd_packet *)buf;
        struct msghdr msg = {0};
        struct iovec iov = { .iov_base = buf, .iov_len = sizeof(buf) };
        char ctrl[1024]; // 用于存放控制信息

        // 配置msghdr以接收控制信息
        msg.msg_name = &amp;si_other;
        msg.msg_namelen = sizeof(si_other);
        msg.msg_iov = &amp;iov;
        msg.msg_iovlen = 1;
        msg.msg_control = ctrl;
        msg.msg_controllen = sizeof(ctrl);

        int len = recvmsg(s, &amp;msg, 0);
        if (len &lt; 0) die("recvmsg");

        uint32_t seq = ntohl(pkt->seq_num);

        if (pkt->type == DATA_PACKET) {
            // 处理数据包：从控制信息中提取硬件接收时间戳
            struct cmsghdr *cmsg;
            for (cmsg = CMSG_FIRSTHDR(&amp;msg); cmsg; cmsg = CMSG_NXTHDR(&amp;msg, cmsg)) {
                if (cmsg-&gt;cmsg_level == SOL_SOCKET &amp;&amp; cmsg-&gt;cmsg_type == SO_TIMESTAMPING) {
                    // 时间戳结构体数组: [0]软件, [1]废弃的硬件, [2]硬件
                    struct timespec *ts_arr = (struct timespec *)CMSG_DATA(cmsg);
                    rx_timestamps[seq % MAX_SEQ] = ts_arr[2]; // ts_arr[2] is HWTSTAMP
                    rx_ts_valid[seq % MAX_SEQ] = 1;
                    break;
                }
            }
        } else if (pkt->type == TIMESTAMP_PACKET) {
            // 处理时间戳包：匹配并计算延迟
            if (rx_ts_valid[seq % MAX_SEQ]) {
                struct timespec tx_ts = pkt->data.ts;
                struct timespec rx_ts = rx_timestamps[seq % MAX_SEQ];

                long long send_ns = (long long)tx_ts.tv_sec * 1000000000 + tx_ts.tv_nsec;
                long long receive_ns = (long long)rx_ts.tv_sec * 1000000000 + rx_ts.tv_nsec;
                long long delay_ns = receive_ns - send_ns;
                
                printf("%-10u | %-18lld | %-15s\n", 
                       seq, delay_ns, inet_ntoa(si_other.sin_addr));

                rx_ts_valid[seq % MAX_SEQ] = 0; // 清理，防止重复计算
            }
        }
    }
    close(s);
    return 0;
}
</code></pre>

    <h4>`sender.c` (发送端)</h4>
    <p>发送端现在需要发送两种包，并使用 `recvmsg` 从错误队列中读取硬件发送时间戳。</p>
    <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;linux/net_tstamp.h&gt;
#include "common.h" // 引入通用头文件

void die(char *s) {
    perror(s);
    exit(1);
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "用法: %s &lt;目标IP&gt; &lt;端口号&gt;\n", argv[0]);
        exit(1);
    }
    const char *server_ip = argv[1];
    int port = atoi(argv[2]);

    struct sockaddr_in si_other;
    int s, slen = sizeof(si_other);

    if ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) die("socket");
    
    // *** 关键步骤: 开启硬件发送时间戳 ***
    // SOF_TIMESTAMPING_TX_HARDWARE: 对发送的包进行硬件时间戳
    // SOF_TIMESTAMPING_SOFTWARE: 作为备选，如果硬件不支持则回退到软件
    int ts_flags = SOF_TIMESTAMPING_TX_HARDWARE | SOF_TIMESTAMPING_RAW_HARDWARE | SOF_TIMESTAMPING_SOFTWARE;
    if (setsockopt(s, SOL_SOCKET, SO_TIMESTAMPING, &amp;ts_flags, sizeof(ts_flags)) &lt; 0) {
        die("setsockopt SO_TIMESTAMPING");
    }

    memset((char *)&amp;si_other, 0, sizeof(si_other));
    si_other.sin_family = AF_INET;
    si_other.sin_port = htons(port);
    if (inet_aton(server_ip, &amp;si_other.sin_addr) == 0) die("inet_aton");

    uint32_t seq = 0;
    while (1) {
        // --- 步骤1: 发送数据包 ---
        struct owd_packet data_pkt;
        data_pkt.type = DATA_PACKET;
        data_pkt.seq_num = htonl(seq);
        snprintf(data_pkt.data.payload, sizeof(data_pkt.data.payload), "Packet %u", seq);
        
        if (sendto(s, &amp;data_pkt, sizeof(data_pkt), 0, (struct sockaddr *)&amp;si_other, slen) == -1) {
            die("sendto data_pkt");
        }

        // --- 步骤2: 从错误队列接收发送时间戳 ---
        char ctrl[1024];
        char dummy_buf[1]; // recvmsg需要一个缓冲区
        struct msghdr msg = {0};
        struct iovec iov = { .iov_base = dummy_buf, .iov_len = sizeof(dummy_buf) };
        
        msg.msg_iov = &amp;iov;
        msg.msg_iovlen = 1;
        msg.msg_control = ctrl;
        msg.msg_controllen = sizeof(ctrl);

        // MSG_ERRQUEUE 是关键！内核通过它返回发送时间戳
        if (recvmsg(s, &amp;msg, MSG_ERRQUEUE) &lt; 0) {
            die("recvmsg from error queue");
        }
        
        struct timespec tx_ts = {0, 0};
        struct cmsghdr *cmsg;
        for (cmsg = CMSG_FIRSTHDR(&amp;msg); cmsg; cmsg = CMSG_NXTHDR(&amp;msg, cmsg)) {
            if (cmsg-&gt;cmsg_level == SOL_SOCKET &amp;&amp; cmsg-&gt;cmsg_type == SO_TIMESTAMPING) {
                tx_ts = ((struct timespec *)CMSG_DATA(cmsg))[2]; // ts[2] is HWTSTAMP
                break;
            }
        }

        // --- 步骤3: 发送带有硬件时间戳的时间戳包 ---
        struct owd_packet ts_pkt;
        ts_pkt.type = TIMESTAMP_PACKET;
        ts_pkt.seq_num = htonl(seq);
        ts_pkt.data.ts = tx_ts;

        if (sendto(s, &amp;ts_pkt, sizeof(ts_pkt), 0, (struct sockaddr *)&amp;si_other, slen) == -1) {
            die("sendto ts_pkt");
        }
        
        printf("已发送序列号为 %u 的数据包和时间戳包 (HW Timestamp: %ld.%09ld)\n", 
               seq, tx_ts.tv_sec, tx_ts.tv_nsec);
        
        seq++;
        sleep(1); // 每秒发送一次
    }

    close(s);
    return 0;
}
</code></pre>

    <h2>第五部分：编译与运行</h2>
    <ol>
        <li><strong>创建文件</strong>: 将上述三个代码块分别保存为 `common.h`, `receiver.c`, `sender.c`。</li>
        <li><strong>编译</strong>:
            <pre><code># 编译接收端
gcc receiver.c -o receiver

# 编译发送端
gcc sender.c -o sender</code></pre>
        </li>
        <li><strong>运行</strong>:
            <p>确保两台机器的PTP服务（如 `ptp4l`）正在运行并已同步！</p>
            <p>在<strong>接收端</strong>机器上 (假设其IP为 `192.168.1.101`):</p>
            <pre><code># 需要root权限来设置socket选项
sudo ./receiver 8888</code></pre>
            <p>在<strong>发送端</strong>机器上:</p>
            <pre><code>sudo ./sender 192.168.1.101 8888</code></pre>
        </li>
    </ol>

    <h2>第六部分：结果解读与限制</h2>
    <h4>预期输出 (接收端)</h4>
    <p>您将在接收端看到类似下面的输出。延迟值现在直接反映了数据包在物理介质和硬件中的渡过时间，其抖动（Jitter）会非常小，数值也更加精确。</p>
    <pre><code>接收端已启动，在端口 8888 上等待数据...
------------------------------------------------------------------
序列号     | 单向延迟 (ns)      | 发送方地址
------------------------------------------------------------------
0          | 4812               | 192.168.1.100
1          | 4799               | 192.168.1.100
2          | 4805               | 192.168.1.100
...
</code></pre>
    <p>（注意：延迟值会非常小，这里仅为示例，实际值取决于您的网络硬件和拓扑。例如，背靠背连接的两台服务器，延迟可能在几百到几千纳秒之间）。</p>

    <h3>限制与注意事项</h3>
    <ul>
        <li><strong>非对称延迟</strong>: 此方法测量的是单向延迟。它假设从A到B和从B到A的路径延迟是相同的，PTP协议本身也基于此假设。在复杂的网络中，路径可能不对称。</li>
        <li><strong>硬件依赖</strong>: 此方案的成败完全取决于网卡和驱动程序对PTP硬件时间戳的正确支持。</li>
        <li><strong>时钟同步质量</strong>: 测量的绝对准确性取决于 `ptp4l` 同步的质量。持续监控 `ptp4l` 和 `phc2sys` 的输出至关重要。</li>
    </ul>

    <h2>总结</h2>
    <p>通过结合PTP进行精密时钟同步，并利用Linux内核提供的 `SO_TIMESTAMPING` 接口获取网卡硬件时间戳，便可实现一种目前可用的、精度最高的网络延迟测量方案。</p>
    <p>虽然实现上比纯软件方法复杂，需要处理
        `sendmsg`/`recvmsg`、控制信息（`cmsg`）和错误队列（`MSG_ERRQUEUE`），但对于高频交易、数据中心网络监控、科学实验等对时间精度有极致要求的场景，这种方法能够提供无与伦比的洞察力，是衡量网络微观性能的黄金标准。
    </p>

    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
        // Use a try-catch block for robustness
        try {
            mermaid.initialize({ startOnLoad: true });
        } catch (e) {
            console.error("Mermaid initialization failed:", e);
        }
    </script>
</body>

</html>